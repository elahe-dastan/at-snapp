\documentclass[a4]{report}

\usepackage{minted}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}
\usepackage[localise]{xepersian}

\settextfont{Vazir}
\colorlet{LightGray}{Gray!30!}

\begin{document}

\عنوان{گزارش کارآموزی\\شرکت ایده گزین روماک (اسنپ)}

\نویسنده{الهه داستان}
\تاریخ{تابستان ۱۴۰۰}

\عنوان‌ساز

\فصل{گزارش‌های هفتگی}

\قسمت{هفته اول - ۲۲ام تیر ماه}

\پاراگراف{}
هفته‌ی اول کارآموزی بیشتر صرف شناخت ساختار شرکت و گرفتن دسترسی‌ها و خواندن کدهای قبلی می‌شود.

\پاراگراف{}
ساختار شرکت اسنپ از ساختار اسپاتیفای\پانویس{Spotify} الهام گرفته شده و حالت شطرنجی دارد.
بدین صورت که هر ونچر (منظور از ونچر بیزینس‌های مختلف می‌باشد،
به طور مثال اسنپ کب\پانویس{Snapp Cab} و اسنپ باکس\پانویس{Snapp Box} و اسنپ دکتر\پانویس{Snapp Doctor} سه ونچر متفاوت اند)
یک مدیر فنی ارشد دارد سپس هر ونچر به چندین چپتر\پانویس{Chapter} تقسیم می‌شود برای مثال در ونچر اسنپ کب که من در آن مشغول هستم
دو چپتر برای بک‌اند داریم که نام یک چپتر، آلفا\پانویس{Alpha} است که عمده سرویس‌هایشان با زبان \متن‌لاتین{PHP} توسعه یافته است و روی کد قدیمی و اولیه‌ی اسنپ کار می‌کنند.
چپتر دیگر براوو\پانویس{Bravo} است که با زبان گولنگ و روی میکروسرویس‌های جدید شرکت که از کد قدیمی جدا شده‌اند، کار می‌کند.

\پاراگراف{}
زبان گولنگ کامپایل شده، سرعت خوبی داشته و یادگیری آن ساده است. همگی این دلایل باعث شده‌اند که سرویس‌های جدید شرکت با این زبان توسعه پیدا کنند.

\پاراگراف{}
هر چپتر یک مدیر دارد که وظیفه‌ی سامان‌دهی به آن چپتر هم از نظر مدیریت افراد و هم فنی را دارد.
هر چپتر به ورتیکال‌های مختلف تفسیم می‌شود که هر ورتیکال مسئول توسعه‌ی میکروسرویس‌های مشخصی است.
هر ورتیکال نیز مدیر خود را دارد، در چپتر ما ورتیکال‌های مختلفی مانند شرد سرویسز، دیسپچیگ و … وجود دارد.

\پاراگراف{}
ورتیکالی که من در آن مشغول هستم یوزر نام دارد و تنها ورتیکالی است که به داده‌های خام کاربران دسترسی دارد و وظیفه ی ارتباط سرویس‌های داخلی
با سرویس‌های خارجی دارد مثلا ساخت اکانت و لاگین کاربران اسنپ در دست این ورتیکال است
یا ثبت نام دیجیتال راننده‌ها توسط این ورتیکال صورت میگیرد که اهمیت آن در دوران کرونا دو چندان شده است.
همچنین پنهان کردن شماره های کاربران هنگام تماس با راننده و چندین سرویس دیگر برعهده این ورتیکال است.

\پاراگراف{}
در شرکت با توجه به نیاز ورتیکال‌ها هر ورتیکال می‌تواند تعداد مختلفی نیرو در کنار نیروهای بک‌اند داشته باشد.
در ورتیکال یوزر به علت حساسیت و تنوع سرویس‌ها در کنار نیروهای بک‌اند،
نیروهای فرانت‌اند، اندروید، تست و دواپس\پانویس{DevOps} همگی حضور دارند.
با حضور نیروهای مدیریت محصول و اسکرام مستر\پانویس{Scrum} بزرگ‌ترین ورتیکال شرکت را تشکیل می‌دهد.

\پاراگراف{}
در شرکت یک نربان پیشرفت وجود دارد که هنگام ورود هر کس سطح او به او گفته می‌شود و هر ۶ ماه با توجه به عملکرد فرد که توسط مدیر ورتیکال، مدیر چپتر
و نظر سایر هم‌تیمی‌های او سنجیده می‌شود می‌تواند سطح وی ارتقا پیدا کند.

\پاراگراف{}
در شرکت از متدلوژی اسکرام استفاده می‌شود.
هر فصل در سال یک کوآرتر محسوب می‌شود که در ابتدای آن شرکت اهداف کلی را تعیین می‌کند،
که این اهداف با نظارت مستقیم مدیر فنی ارشد ونچر مشخص می‌شود.
این اهداف در اختیار ورتیکال‌ها قرار می‌گیرد و هر ورتیکال دو هفته فرصت دارد تا اهداف خود را مشخص کند به طوری که در راستای اهداف شرکت قرار بگیرد.
در ابتدای هر کوآرتر جلسات زیادی برای طراحی فنی پروژه‌ها، تخمین زمانی هر یک و \نقاط‌خ می‌شود.
هر کوآرتر به ۶ اسپیرینت\پانویس{Sprint} دو هفته‌ای تقسیم می‌شود و در ابتدای هر اسپیرینت نیز جلساتی برای انتخاب تسک‌ها و تخمین زمان آن ها تشکیل می‌شود.
در انتهای هر اسپیرینت نموداری توسط اسکرام مستر کشیده می‌شود که نشان دهنده‌ی عملکرد اعضا و عملکرد کلی تیم است
و با توجه به آن ظرفیت تیم برای اسپرینت بعدی تخمین زده می‌شود.
همچنین در انتهای هر کوآرتر اسکرام مستر با تک تک اعضا جلساتی خواهد داشت تا از دغدغه‌ها و مشکلات آن‌ها مطلع شود.
یک جلسه رترو\پانویس{Retro} نیز تشکیل خواهد شد تا هر کس نقد ها و پیشنهادات خود را برای کوآرتر بعد بیان کند و
همچنین هر کس باید به صورت ناشناس درباره ی هم تیمی هایش نظر بدهد.

\پاراگراف{}
پس از اینکه یک عضو جدید به شرکت اضافه می‌شود یک فرد از خود تیم به عنوان بادی به او معرفی می شود
که وظیفه دارد او را با تیم و سرویس‌ها آشنا کند و همچنین دسترسی‌های او را برایش فراهم کند.
هر برنامه‌نویس پس از اضافه شدن به تیم باید یک وی پی ان از شرکت بگیرد که تنها به وسیله‌ی آن می‌تواند به سرویس‌ها دسترسی داشته باشد.
همچنین باید دسترسی به ایمیل سازمانی، گیت‌لب\پانویس{Gitlab} که مخزن اصلی نگهداری کدها می‌باشد،
جیرا\پانویس{Jira} که برای مدیریت تسک‌ها می‌باشد،
کانفلوئنس\پانویس{Confluence} که برای مدیریت مستندات می‌باشد
و اسنپ کلاد\پانویس{SnappCloud} که سرویس ابری شرکت مبتنی بر \متن‌لاتین{Openshift} می‌باشد
را بگیرد.
همچنین برای آشنا شدن فرد جدید با تیم در هفته‌ی اول سعی می‌شود جلسات غیرکاری تشکیل شود که در آن اعضا بازی‌های گروهی انجام می‌دهند
و با یکدیگر آشنا می‌شوند.
همچنین فرد جدید در هفته‌ی اول باید ساختار کد‌های شرکت را مطالعه کند
و همچنین مستندات سرویس‌های ورتیکالش را مطالعه کند
تا با معماری سرویس‌های ورتیکال و شرکت آشنا شود
و بداند هر کدام از سوریس‌های تیم با چه سرویس‌هایی از سایر ورتیکال‌ها در ارتباط است.

\قسمت{هفته دوم - ۲۹ تیر ماه}

\پاراگراف{}
پس از اینکه با سرویس‌های شرکت به طور کلی آشنا شدم حال باید روی یک سرویس شروع به توسعه می‌کردم.
سرویسی که برای شروع انتخاب شد سرویس ستار بود که عمل پنهان کردن شماره‌های کاربران و رانندگان را انجام می‌دهد تا امنیت بیشتری برای سفر فراهم کند.
به علت قرارداد عدم افشای اطلاعات\پانویس{NDA} که با شرکت امضا شده است و حساسیت کار این ورتیکال از توضیح معماری سرویس یا کد به هر شکل و حتی ذکر نام شرکت‌های
طرف قرارداد کاملا معذورم و به اجبار به توضیحات زیر بسنده می‌کنم.

\پاراگراف{}
سرویس پنهان کردن شماره‌های تماس در شرکت یکی از پایدارترین سرویس‌های شرکت است
که برای انجام کار خود به اطلاعات راننده‌ها و مسافران نیاز دارد
به همین جهت با پایگاه‌های داده‌ای متعددی سر و کار دارد.
همچنین برای سرعت عمل بالا از \متن‌لاتین{Redis} به عنوان حافظه نهان استفاده شده است.
برای پنهان کردن شماره‌ها شرکت با فراهم کنندگان مختلفی قرارداد دارد که ما را در این امر برقراری تماس را برعهده دارند.
سرویس‌های ما نیاز به فراخوانی این فراهم‌کنندگان دارند.
همچنین ستار خود توسط سرویس‌های دیگری از ورتیکال‌های دیگر نیز فراخوانی می‌شود و از این رو سرویس ستار
کیت توسعه سرویس (SDK) نیز دارد.
به علت وابستگی بالای این سرویس به پایگاه‌های داده‌ای مختلف و علم به اینکه پایگاه‌های داده‌ای
برای زیرساخت‌های ابری مناسب نیستند، تا اکنون این سرویس روی ماشین‌های مجازی بوده که یکی از تسک‌های مهم آن بردن این سرویس بر روی ابر است.
همچنین این سرویس تا کنون برای حالت اسنپ برای دیگری فعال نبوده که یکی از تسک‌های مهم اضافه کردن این ویژگی به آن است که طبیعتا باعث
می‌شود نیاز داشته باشیم با سرویس در شرکت به نام مورفیوس که وظیفه‌ی ارسال پیامک را دارد جهت اطلاع‌رسانی شماره‌ی پنهان شده به کاربر نیز در ارتباط داشته باشیم.
اولین مشکلی که در در این سرویس وجود داشت بحث نشت حافظه آن بود.
زمانی که در سیستم مانیتورینگ به عملکرد این سرویس در یک بازه‌ی زمانی نستا بزرگ نگاه می‌کردیم قابل مشاهده بود که حافظه مصرفی این سرویس با شیب کمی همواره در حال
افزایش است.
البته این حل این مشکل اولویت شرکت نبوده چرا که اولا اگر این سرویس از کار بیافتد نهایتا شماره‌ها پنهان نخواهند شد
که این امر در عملکرد کلی شرکت خللی وارد نمی‌کند و از طرفی چندین نسخه از این کد بالا آورده شده است که هر زمان مموری مصرفی هر کدام از حد مشخصی عبور کرد
آن نسخه با توجه به تنظیمات صورت گرفته به طور خودکار راه‌اندازی مجدد خواهد شد.
تسک اول من جستجو در کد و تحقیق جهت پیدا کردن مشکل نشتی حافظه و حل آن بود.
در جهت جستجو برای حل این مشکل اقدامات زیر انجام شد.

\پاراگراف{}
کد این سرویس نسبتا زیاد است و خواندن خظ به خط آن احتمالا زمان بسیار زیادی می‌خواست بنابراین روش بهتر این بود که یک نسخه از کد را داخل محیط تستی شرکت بالا بیاورم و
سپس آن را مانیتور کنم. اگر بدون اینکه کد زیر بار باشد سایز هیپ\پانویس{Heap} مرتبا افزایش پیدا کند به احتمال زیاد باید یک گوروتین\پانویس{Goroutine} داخل کد وجود داشته باشد
که در پس زمینه همواره در حال اجرا است و مشکلی در آن وجود دارد.
البته سایز هیپ در حالتی که ریکويستی زده نمیشد افزایش پیدا نمیکرد پس مجبور شدم آن را زیر باز ببرم این کد چندین API داشت و هر یک را لود تست و به سایز مموری رجوع می‌کردم.
هر API که زیر باز قرار گرفتن آن باعث افزایش سایز مموری شود سر نخ خوبی برای پیدا کردن مشکل است.
برای لود تست کردن از کتابخانه‌ی \متن‌لاتین{bombardier}\پانویس{https://github.com/codesenberg/bombardier} و تکه کد زیر استفاده کردم.


\begin{latin}
\begin{minted}[bgcolor=LightGray]{bash}
#!/bin/bash

for i in {1..5} ; do
  for j in {1..2000};do
    curl -v -X POST -d '{"enable": true}' \
        -H 'Content-Type: application/json' \
        https://my-service.io/api/method
    sleep .5
  done
  sleep 5m
  curl -L https://my-service.io/debug/pprof/heap > heap.$i.pprof
done
\end{minted}
\end{latin}

بعد از پیدا کردن API مورد نظر شروع به خواندن کد مربوط به آن API کردم. نکته‌ی اول که باید مد نظر قرار دهیم این است که یک کانکشن باز یا هر مورد دیگری نمی تواند باعث مموری لیک شود
اگر کد دچار مموری لیک شده یعنی داریم تکه کد مخربی را داخل یک حلقه برای مدت زمان زیادی اجرا می‌کنی.م هنگام خواندن کد باید به نکات مهمی داخل گولنگ توجه کنیم از جمله

\شروع{شمارش}
\فقره رفرنس‌ها
\فقره کانتکست‌ها
\فقره کانکشن‌ها
\فقره تیکرها
\پایان{شمارش}

\پاراگراف{}
به کدی که در ادامه می‌آید دقت کنید. یک نمونه از دیتابیس ساخنه شده و به تابع داده شده است. سپس داخل تابع یک استراکت ساخته شده که نمونه دیتابیس به عنوان یک فیلد از آن استراکت قرار گرفته است.
ممکن است انتظار داشته باشیم بعد از برگشتن از تابع \متن‌لاتین{Garbage Collector} استراکت ساخته شده را از بین ببرد اما این اتفاق نمی افتد.
چرا که این استراکت به نمونه دیتابیس رفرنس دارد که نمیتواند از بین برده شود. این اتفاق زمانی می افتد که با اشاره‌گرها کار می‌کنیم.

\begin{latin}
\begin{minted}[bgcolor=LightGray]{go}
package main

import (
        "database/sql"
        "log"
)

type Struct struct {
        db *sql.DB
        // some other fields
}

func main() {
    db, err := sql.Open("driverName", "dataSourceName")
    if err != nil {
        log.Fatalf("Cannot open database dataSourceName: %s", err)
    }

    DoSomething(db)
}

func DoSomething(db *sql.DB) {
    s := Struct{db: db}
    // do something
}
\end{minted}
\end{latin}

\پاراگراف{}
فراموش نکنید که کانتکست ها را کنسل کنید.

\begin{latin}
\begin{minted}[bgcolor=LightGray]{go}
package main

import "context"

func main() {
    ctx, cancelCtx := context.WithCancel(context.Background())
    defer cancelCtx()
}
\end{minted}
\end{latin}

\پاراگراف{}
هر سوکت که باز می‌شود باید حتما بسته شود. البته اکثرا از کتابخانه‌ها برای باز کردن سوکت استفاده می‌کنیم. این کتابخانه ها خود موارد مختلفی را هندل می‌کنند تا بعد از اتمام کار ما سوکت بسته شود.
اما به هر حال باید به آن توجه کنیم چراکه حالاتی وجود دارد که سوکت باز می‌ماند به تکه کد زیر دقت کنید.

\begin{latin}
\begin{minted}[bgcolor=LightGray]{go}
package main

import (
    "database/sql"
    "log"
)

type Storage struct {
    db *sql.DB
    // some other fields
}

func (s *Storage) fetchAll() {
    // *Rows should be closed
    rows, err := s.db.Query("SELECT * FROM somewhere")
    if err != nil {
            log.Fatal(err)
    }

    defer func() {
        err := rows.Close()
        if err != nil {
                log.Fatal(err)
        }
    }()

    if err := rows.Err(); err != nil {
        log.Fatal(err)
    }

    // If Next is called and returns false and there are no
    // further result sets, the Rows are closed automatically
    // but an error may occur inside the block
    for rows.Next() {
        // If this error or any other one occurs, this loop doesn't continue
        // so if I hadn't called close in a defer function we would have an
        // open connection forever
        err := rows.Scan("&dest")
        if err != nil {
            return
        }
    }
}

func main() {
    // usually we make a single db instance and use
    // it during the whole project life,
    // so it's rare to call Close function on it
    db, err := sql.Open("driverName", "dataSourceName")
    if err != nil {
        log.Fatalf("Cannot open database dataSourceName: %s", err)
    }

    s := Storage{db: db}
    s.fetchAll()

    // some other code
}
\end{minted}
\end{latin}

\پاراگراف{}
دقت کنید که تیکرها بعد از شروع، متوقف شوند.

\begin{latin}
\begin{minted}[bgcolor=LightGray]{go}
package main

import "time"

func main() {
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()
}
\end{minted}
\end{latin}

\پاراگراف{}
مشکل کد که باعث نشتی حافظه می‌شد به دلیل ساختن تیکرها داخل حلقه و متوقف نکردن آن‌ها بود. تکه کدی مانند زیر


\begin{latin}
\begin{minted}[bgcolor=LightGray]{go}
package main

import "time"

func main() {
    go func() {
        for time.Now(); true; <-time.NewTicker(time.Second).C {
            // Do something
        }
    }()

    // Do something
}
\end{minted}
\end{latin}

\پاراگراف{}
برای آنکه مطمئن شوم نشتی حافظه به دلیل تکه کد بالا به وجود آمده است با تکه کد زیر آن را تست کردم:

\begin{latin}
\begin{minted}[bgcolor=LightGray]{go}
package main

import (
    "fmt"
    "runtime"
    "time"
)

func main() {
    // Below is an example of using our PrintMemUsage() function
    // Print our starting memory usage (should be around 0mb)
    PrintMemUsage()

    ticker := time.NewTicker(time.Millisecond)
    defer ticker.Stop()
    for time.Now(); true; <-ticker.C {
        a := 2
        a *= 2
        if a == 1024 {
            a = 2
            // Force GC to clear up, should see a memory drop
            runtime.GC()
        }
        PrintMemUsage()
    }
}

// PrintMemUsage outputs the current,
// total and OS memory being used.
// As well as the number
// of garage collection cycles completed.
func PrintMemUsage() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)

    // For info on each,
    // see: https://golang.org/pkg/runtime/#MemStats
    fmt.Printf("Alloc = %v MiB", bToMb(m.Alloc))
    fmt.Printf("\tTotalAlloc = %v MiB", bToMb(m.TotalAlloc))
    fmt.Printf("\tSys = %v MiB", bToMb(m.Sys))
    fmt.Printf("\tNumGC = %v\n", m.NumGC)
}
\end{minted}
\end{latin}

برنچی از مستر گرفتهو این تکه کد که باعث نشتی حافظه می‌شد را تغییر دادم و مرج ریکويست را قرار دادم. پس از مرور برنچ توسط مدیر ورتیکال این برنچ با مستر مرج شد.

\قسمت{هفته سوم - ۵ام مرداد ماه}

\پاراگراف{}
در هفته‌ی سوم فرصت برای توسعه‌ی بیشتر روی سرویس ستار به وجود آمد.
در هنگام گرفتن سفر در اکانت می‌توانید مشخص کنید که این سفر را برای خوتان می‌خواهید یا برای دوستتان.
اگر سرویس پنهان کردن شماره را فعال کرده باشید و اسنپ را برای خودتان بخواهید هیچ مشکلی نخواهید داشت اما اگر برای فرد دیگری سفر بگیرید شماره‌ها پنهان نخواهند شد.
تسک این هفته اضافه کردن این قسمت به کد بود.
با توجه به اینکه کد بسیار ماژولار بود و هر عملکرد یکتایی تابع و استراکت خود را داشت اضافه کردن این فیچر کار بدون دردسری بود.
در ابتدا تنها دو نفر داخل مساله بودند حال با اضافه کردن نفر سوم گراف ذهنی ما باید
تغییر پیدا کند.

\includegraphics[scale=0.5]{fig/call-graph}

\پاراگراف{}
در گراف بالا نود دوست اضافه شده است که باید به کد نیز اضافه میشد علاوه بر آن زمانی که سفر برای دوست گرفته می‌شود و سرویس ستار فعال است
باید از طریق پیامک شماره‌ی پنهان شده‌ی راننده به فرد سوم مورد نظر اطلاع‌رسانی شود.
به همین دلیل باید با سرویس مورفیوس که وظیفه‌ی پیام رسانی را دارد نیز ارتبط می داشتیم همچنین این سرویس توسط سرویس های دیگری داخل شرکت صدا زده میشد که از اس دی کی استفاده می کردند به همن جهبت اس دی کی این سرویس نیز باید تغییر داده میشد و به تیم هایی که این سرویس را کال می کردند اطلاع رسانی میشد


\پاراگراف{}
پس از اضافه کردن فیچر ریویو توسط مدیر مستقیم ورتیکال و رفت و آمد برای تغییر کد بعد از ریویو نوبت به تست آن می شود چون هیچ فیچر جدید یا تغییر زیاد در کد بدون امضای کیو ای نمی تواند ریلیز شود برای تست کردن باید ابتدا کد را داخل محیط تستی دیپلوی می کردم و در ارتباط با کیو ای می بودم تا اگر باگی در کد وجود داشت با مانیتور کردن لاگ ها هنگام تست متوجه اشکال میشدم پس از تست کیو ای برنچ به برنچ مستر مرج می شود حال برای لانچ این فیچر باید کد جدید روی سرورها دیپلوی شوند دیپلوی حتما باید در نیمه شب انجام شود تا اگر به هر دلیل دان تایمی به وجود ضرر کمتری به بیزینس شرکت وارد شود تنها مدیر مستقیم ورتیکال اجازه ی دیپلوی و دسترسی اس اس اچ به سرور ها پروداکشن دارد علاوه بر او باید فرد دیگری که کعکولا توسعه دهنده ی فیچر استحضور داشته باشد و در زمان دیپلوی به دقت سرویس را مانیتور کند و اگر تغییر غیر عادی در ترافیک سرویس ها دید باید فیچر سریعا رول بک شود لازم به ذکر است برخی از فیچرها که بسیار حساس باشند علاوه بر تایید مدیرمستقیم ورتیکال به تایید مدیر چپتر نیز نیاز دارند

\پاراگراف{}
گروه های رسمی ای در شرکت تشکیل می شود که یکی از آن ها مربوط دیپلوی سرویس هاست هر تیم قبل از ریلیز باید در آن گروه اعلام کند که در حال دیپلوی است و نام سرویس را ذکر کند تا اگر مشکلی به وجود آمد تمامی افراد از جمله دواپس بدانند که ریلیزی صورت گرفته و تمامی احتمالات را در نظر بگیرند

\end{document}
